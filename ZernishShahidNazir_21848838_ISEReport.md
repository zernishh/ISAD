# Cover page [in progress]

# Introduction [in progress]

# Module descriptions

##### SeasonModule:

##### Submodule validateInput

- **Imports:** country, month (strings) provided by user
- **Exports:** None
- **Description:** Validates the input provided by the user for determining the season of the year and checks if the provided country and month are valid inputs.

##### Submodule findSeason

- **Imports:** country, month (strings) provided by user
- **Exports:** season (string) determined by the module
- **Description:** Determines the season of the year based on the country name and month provided by the user. If the provided country and month are valid, the module returns the corresponding season.

##### TemperatureModule:

##### Submodule validateInput

- **Imports:** city (string), temperature (double) provided by user
- **Exports:** None
- **Description:** Validates the input provided by the user for analysing the temperature of a city and checks if the provided city name and temperature reading are valid inputs.

##### Submodule compareTemperature

- **Imports:** city (string), temperature (double) provided by user
- **Exports:** message (string) message generated by the module based on the temp analysis
- **Description:** Compares a given temperature reading with the average temperature of a city and generates an appropriate message. If the temperature reading is within the valid range for the city, the module compares it with the average temperature of the city and generates appropriate response.

##### Submodule getDailyMeanTemperature 
- **Imports:** city (string) provided by user 
- **Exports:** dailyMeanTemperature (double) determined by the module 
- **Description:** Retrieves the daily mean temperature based on the city name provided by the user.

##### Design decisions and modularity

I created two modules, one for each scenario and further divided each module into two submodules.
##### SeasonModule:

- Divided into two modules, validateInput and findSeason, to avoid problems and promote reusability.
- Ensures that each module has a single responsibility, making it easier to understand and maintain.

##### TemperatureModule:

- Also divided into two modules, validateInput and compareTemperature.
- Allows for better organization and clarity in the code.

##### Modularity Principles:

- **Divide and Conquer:** Dividing the functionality into smaller modules facilitates easier development, testing, and maintenance. Each module focuses on a specific task, promoting clarity and reducing complexity.
- **High Cohesion:** Each module performs a single well-defined task, enhancing clarity and reducing the likelihood of bugs. Promotes code reuse and makes it easier to update or modify specific functionalities without affecting others.
- **Low Coupling:** Modules communicate through well-defined interfaces (Imports and Exports), reducing interdependencies. Changes in one module are less likely to impact others, promoting flexibility and maintainability. By having the functionality separated into different classes, I’ve reduced the coupling between them.
- **Input Handling and Output Availability:** When handling inputs, modules validate input data to ensure that only valid inputs are processed further. Error handling is implemented to handle invalid inputs and provide meaningful feedback to the user. As for the outputs, each module exports relevant data or messages, making them available for further processing or display.
- **The structure allows for easy extension or modification of functionalities throughout the project. New modules can be added or existing ones modified without affecting the overall system.** 

# Modularity
##### How to run code with correct commands 
-	Compile the code “javac WeatherTool.java”
-	Execute, run the WeatherTool program “java WeatherTool”
-	Follow the prompts; choosing between scenario 1 and 2 
-	Depending on the scenario chosen, the program will provide information about the season for a given country and month, or whether a temperature reading is above or below average for a city.

##### Sample output of running production code
![sample output](example1.png)


##### brief explanation on application of modularity concepts 
-	My code applies modularity concepts, including low coupling and high cohesion. Low coupling is achieved by making sure that the modules are loosely connected, meaning changes in one module would minimally impact the others, which creates a more flexible and easily maintainable code. 
-	My code maintained high cohesion by grouping related functionalities with each module, separating them between the two given scenarios. Therefore my code has a modular design and is maintainable and scalable. 

##### Checklist Review Results 
| Item | Checklist question related to modularity | Yes/No | Description of the issue if No is the answer |
|------|-------------------------------------------|--------|----------------------------------------------|
| 1    | Does code exhibit low coupling between modules? | Yes |                                                 |
| 2    | Are cross-module function dependencies minimised? | Yes |                                             |
| 3    | Are global variables avoided? | Yes |                                                                |
| 4    | Control flags used appropriately? | Yes |                                                                |
| 5    | Are parameters received in correct order? | Yes |                                                             |
| 6    | Is a tolerance value used when comparing real numbers for equality? | Yes |                                            |
| 7    | Does each method clearly person a single task? | Yes |                                                             |
| 9    | Is redundancy minimised? | No | There are similarities in the validation part for the methods in TemperatureModule |

##### Refactoring Decisions 
Generally, my code shows good modularity practices. It demonstrates low coupling between modules, minimised dependencies between modules, and avoidance of inconvenient global variables. Each method performs a single task, enhancing clarity and maintainability. However, the review of the checklist highlighted the main issue related to code redundancy. Specifically there were similarities in the validation part for the methods in the TemperatureModule class, indicating potential redundancy. 

To address the issue of redundancy, I refactored the ‘TemperatureModule’ class to reduce the duplication of code. Previously both the ‘validateTemperature’ and ‘compareTemperature’ methods had similar logic to assign the daily mean temperature based on the city. This duplication was removed by introducing a new private method ‘getMeanTemperature’.

This method separated the logic for retrieving the daily mean temperature based on the city name, to a separate method. Both ‘validateTemperature’ and ‘compareTemperature’ now call this other method to get the daily mean temperature, reducing redundancy and making the code easier to maintain. By refactoring the code in this way, I ensured that if the logic for determining the daily mean temperature needs to be changed in the future, it only needs to be updated in one place (getDailyMeanTemperature method) rather than in multiple places, reducing confusion and errors. 
Finally, I revised module descriptions to add the new method.




